# Chapter 5; 문법

## 문과 표현식
표현식 : 결과값이 존재하는 문장
>18*3, a+b, a 등등.. 값이 존재하는 것들

문 : 표현식을 의미있게 만들어주는 표현식들과 연산자들의 집합체(?)
>var a = 18*3; / b; / var a = b; 등

### 문의 완료 값
F12를 눌러서 Console창에 *var a = 1;* 라고 작성해보자.
그러면 undefined라고 출력이 될 것이다.
명세에 *var문의 완료 값은 undefined이다.* 라고 적혀있기 때문이다.

또한 **{ }** 블록은 내부의 가장 마지막 문 혹은 표현식의 완료 값을 반환하는데, 아래의 코드를 보면 이해가 쉬울 것이다.
```javascript
if(true)
{
	var a = 10;
}
// result : undefined
var a = 0;
if(true)
{
	a = 10 + 20;
}
// result : 30
```

그러면, 문의 완료 값을 얻을 수 있는 방법은 없을까?
2가지의 방법이 존재한다.
1. eval()
2. do{}

eval은 제-발 사용하지말라고 필자가 작성해두었다.
되도록이면, 아니 제발 do{ } 를 쓰라고 언급해주고 있다.

### 표현식의 부수 효과
표현식들은 부수효과가 없다.
But 함수 표현식은 간접적이나마 부수 효과를 낸다.
> 함수 내부에서 다른 변수의 값을 변경해줄 때.

즉, 부수 효과는 표현식 자체가 변수나, 특정 대상의 값에 영향을 끼칠 때라고 생각하면 된다.
> 증감 연산자, 대입 연산자, 복합 할당 연산자 등 부수 효과를 가지고 있다.


### 콘텍스트 규칙
#### 중괄호
중괄호가 나오는 부분 
1. 객체 리터럴
2. 레이블

객체 리터럴 같은 경우에는   { }가 변수에 할당되는 값이 된다.
레이블은 뭘까?
음.. 내가 이해한 바로는, 일종의 별명을 붙여준 것이라 생각한다.
중괄호로 묶인 스코프를 Label처리하는 느낌?
break나 continue를 이용하여 해당 스코프를 나오거나, 진행할 수 도있지만 별로 추천하고 있지는 않다.
#### 블록
```javascript
[] + {}; // result : "[Object Object]"
{} + []; // result : 0
```
매우 신기하다.
첫 번째의 경우에는 **{ }**를 블록이 아닌 객체로 인지하여 [Object Object]로 강제 변환이 된 것이고, 두 번째의 경우에는 객체가 아닌 블록이라 생각을 했기에 ** + [ ] **만 계산된 것이다.
**결론** 저렇게 쓸 일 없다.

#### 객체분해
ES6부터 객체를 분해 하기 위해서 { }를 사용한다.
```javascript
function getData(){
	return { a: 42, b: 44 }; 
}
var { a, b } = getData();

var r = getData();
var a = r.a;
var b = r.b;
```
return으로 넘어온 객체에 대해서 두 번째 경우와 같이 분해하는 것보다 첫 번째처럼 분해 할당하는 것이 더 좋다.

이는 함수의 인자에도 사용이 가능한데
```javascript
function getData({a,b,c})
{
   ...
}
getData({c:1,a:333,b:32});
```
들어온 객체의 key값(?)에 맞춰서 자동으로 분배 할당 해준다.
즉, a는 333, b는 32, c는 1으로 순서와 관계 없이 key값에 맞춰 넣어준다는 의미이다.

#### else - if 문
그냥.. 읽어만보면 그렇구나 하는 느낌이다.
JS에는 else if문이 없고, else 뒤 if문을  중괄호로 묶지 않아도 되기에 약간의 눈속임이다.
```javascript
if(a){
}
else if(b){
}
------------------------------
if(a){
}
else{
	if(b){
	}
}
```
위 두 코드는 완벽히 일치히다. else문에 있는 중괄호를 삭제하면, 첫 번째 코드와 동일하다.
그냥 알고만 있자.

### 연산자 우선 순위
연산자의 우선 순위를 모르면 우리가 예상하지 못한 결과가 나오기도 한다.
예를 들어 ||과 &&의 우선순위를 모른다면 아래 코드를 혼동할 수 있다.
```javascript
var a = 10;
var b = "abc";
var c = 0;
a || b && c; // 10
a && b || c; // "abc"
```
우선 순위는 && > || 이며 이와 관련된 자료는 인터넷으로 찾아보는게 더 빠르다고 책에서 설명한다. 

## 단락 평가
음.. 사실 이 단락 평가라는 용어를 처음 들어봤는데, 공부하다보니 자주 써먹는 내용이다.
예를 들어, a객체의 b 속성이 null이 아닌지 판단하고 싶을 때가 있다.
근데 애초에 a객체가 null이라면? Exception오류를 내기도 한다.
따라서 먼저 상위 객체가 null이 아닌지 체크를 하는 것이 단락평가이다. ( 구지 null이 아닌지 체크하는게 아니라 가드역할을 하는게 단락평가이다.)

&&연산은 좌측 피연산자가 falsy면 우측은 보지도 않고 false 이라는 점을 응용하면 될 것이고, || 연산은 좌측 피연산자가 truthy면 우측은 보지도 않고 true라는 점을 응용하면 된다.

이 뒷 부분에 **끈끈한 우정, 결합성** 파트는 사실 왜 파트를 나눴는지 모르겠지만 정리를 하자면 아래와 같다.
1. 우선순위는 && > || > 삼항연산자
2. &&과 ||의 결합방향은 좌->우, 삼항연산자의 결합방향은 우->좌이다.

**결론** : 우선순위를 명확하게 **( )** 로 그룹핑해서 알려주자!
 
 # 작성중 
