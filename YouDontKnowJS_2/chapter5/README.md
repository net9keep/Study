# Chapter 5; 스코프 클로저

## 1. 깨달음
**"아, 클로저는 내 코드 전반에서 이미 일어나고 있었구나! 이제 난 클로저를 볼 수 있어!"**


## 2. 핵심
앞의 내용은 모두 자르고 핵심을 말해보겠다.
일단 아래의 코드를 살펴보자.

```javascript
function foo(){
	var a = 2;
	function bar(){
		console.log(a);
	}
	return bar;
}
var baz = foo();
baz(); // 2
```
앞의 내용을 제대로 이해했다면 bar()가 foo()의 렉시컬 스코프에 접근할 수 있다는 것을 알 수 있을 것이다.
여기서 핵심은 **baz라는 변수를 통해서 bar()함수를 호출했다.** 라는 것인데
눈으로 봤을 때도 baz와 bar의 스코프는 명확하게 다르다.
bar의 렉스컬 스코프는 foo() 함수 블록이고 baz의 렉시컬 스코프는 global이기 때문이다.

근데, 함수 foo()가 실행되고 내부의 스코프가 가비지 컬렉터로 정리되지 않았을까? 만약 foo 내부의 어떤 것이 사용 중이라면 아직 가비지 컬렉터는 메모리 정리를 하지 않았을 것이다.

baz가 실행되니까, 아직 메모리 정리가 되지 않았을텐데.. 그러면 누가 사용 중인 것일까?
바로 bar() 자신이 사용중인 것이다.
> 명확히 말하자면 참조 당했기 때문이다.

bar()는 foo()의 렉시컬 스코프 클로저를 가지고 foo는 bar가 나중에 참조할 수 있도록 스코프를 살려둔다.

baz를 통해서 bar는 살아 있으며, bar는 foo의 렉시컬 스코프 클로저를 가지고 있기 때문에 a에 접근이 가능한 것이다.

함수는 완벽하게 원래의 렉시컬 스코프를 벗어나서 실행 되었지만, **클로저**의 영향 덕분에 해당 렉시컬 스코프에 계속 접근이 가능한 것이다.
어떤 방식이든 다른 위치에서 ( 다른 말로 하자면 서로 다른 렉시컬 스코프에서 ) 접근할 수 있도록 해주는 것이 클로저의 역할이다.

```javascript
function foo(){
	var a = 2;
	function baz(){
		console.log(a);
	}
	bar(baz);
}
function bar(fn){
	fn();
}
```
위의 코드 또한 클로저의 영향을 받아서 bar함수에 baz함수를 fn으로 넘겨 실행을 시킬 수 있다.

## 3. 나는 이제 볼 수 있다.
```javascript
function wait(message){
	setTimeout(function timer(){
		console.log(message);
	},1000);
}
wait("Hello");
```
내부 함수 timer를 setTimeout의 인자로 전달했고, wait의 렉시컬 스코프 내부에 있으므로 message변수에 접근이 가능할 것이다.
wait함수를 실행 한 후, 1초 뒤에는 wait 내부의 스코프가 사라져야하지만 그렇지 않다.

엔진 내부에 setTimeout()에 참조가 존재하여 timer를 호출하므로 앞서 언급한 내용과 똑같이 스코프를 유지시킨다.

>jQuery에 대한 내용은 생략하겠다.

IIFE는 클로저의 예라고 하지만 단순한 IIFE는 클로저의 사례로 들 수 없다.
```javascript
var a = 2;
(function IIFE(){
	console.log(a);
})();
```
위 IIFE는 단순히 렉시컬 스코프 검색으로 a를 참조했을 뿐, IIFE가 해당 스코프 외각에서 호출된 적이 없기 때문이다.

하지만 클로저와 연관이 깊으니 코드를 잘 짜면 될 것 같다.
> 가장 어려운걸 가장 쉽게 말하다닛..

## 4. 반복문과 클로저


