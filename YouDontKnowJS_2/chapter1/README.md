# Chapter1; 스코프
스코프 ⇒ 변수가 어디에 저장되고, 어떻게 찾는지에 대한 정의와 규칙

JS Complier는 다른 컴파일러와 다르게, 입력과 동시에 바로 실행될 수 있게 한다.

## 스코프 이해
JS에서는 코드를 실행하기 위해
1. 스코프 => 엔진을 도와 선언된 변수를 관리한다. 엄격한 규칙을 통한 변수의 적용방식 선정
2. 컴파일러 => 파싱과 코드생성의 모든 행위를 진행한다.
3. 엔진 => 컴파일레이션의 시작부터 끝까지 책임지는 녀석

이 필요하다.
### 구문의 작동
```
var a = 2;
```
위의 코드에서 컴파일러는 아래와 같은 행위를 통해 코드를 실행한다.
1. var a를 만나면 스코프는 a를 스코프 컬렉션에서 찾는다. 만약 찾지 못하면 스코프 컬렉션에 선언 요청을 하고, 찾는다면 선언을 하지 않고 지나간다.
2.  컴파일러는 ``` a = 2 ``` 를 위해서 a를 스코프한테 사용 가능한지(접근이 가능한지) 물어보고, 가능하면 a에 2를 대입한다.

### 컴파일러 체
RHS ( Right Hand Side)
LHS ( Left Hand Side)
각각 대입 연산이 오른쪽으로 가느냐, 왼쪽으로 가느냐를 뜻한다.
``` a = 2 ``` 는 대표적인 LHS이다. 그렇다면 RHS는 어떤 경우가 있을까?
``` console.log(a) ``` 의 경우에는 RHS이다. a라는 변수를 console.log에 전달해줬기 때문이다.
이런 의미에서 RHS는 *값을 가져와라* 라고도 할 수 있는데 아래의 코드는 RHS, LHS가 어디어디에 있는지 확인하면서 확실하게 이해할 수 있다.

```javascript
function foo(a){
	console.log(a);
}
foo(2);
```
먼저 우리는 function foo(a)는 이미 스코프에 올라가 있음을 인지해야한다.
따라서 실질적으로 ``` foo(2); ``` 가 먼저 실행되는데, ``` foo()```라는 함수 자체를 스코프에서 찾아 가져오므로 RHS 참조가 존재한다.
이후, ```foo()```의 인자인 a에게 2를 넘겨주므로 ``` a=2``` 구문이 숨겨져 있다. 
여기서 LHS연산이 이루어진다.
이후, ``` console.log(a); ```로 넘어가는데 , console 객체에 log 메서드가 있는지 스코프에서 확인하므로 RHS 참조가 존재한다.
존재함을 확인하면 변수 a에 있는 값인 2를 가져오므로 RHS참조, 이후 log 메서드에 2를 전달하므로 LHS 연산이 순차적으로 발생한다.

> 이후 존재하는 퀴즈는 생략한다.


## 중첩 스코프
스코프는 변수를 찾는 일련의 규칙 집합이라고 설명을 했지만, 블럭이 여러 개이고 안에 있는 변수들이 중첩된다면? 고려해야할 스코프가 많아진다는 것을 의미한다.

### 중첩 스코프는 이렇게 진행된다. 
 - 엔진이 현재 스코프 내에서 변수를 찾지 못하면 한 단계 위의 스코프로 이동한다.
 - 최상위 Global 스코프에 도달한다면 찾든, 찾지 못하든 멈추게 된다.



## 오류
RHS는 최상위 스코프까지 올라가서 변수를 찾지 못하면 **ReferenceError** 를 내놓는다.
LHS는 최상위 스코프까지 올라가서 변수를 찾지 못하면 Gobal 스코프에 해당 이름을 가진 변수를 생성시킨다. (But, strict mode일 경우 ReferenceError를 내놓는다.)
>strict mode?  --> 엄격한 검사를 진행하는 mode이며, 사용자 실수를 이해하지 않고 모두 Error처리를 하는 mode이다.

