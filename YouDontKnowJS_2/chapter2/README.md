# Chapter 2; 렉시컬 스코프
스코프는 크게 두 종류의 스코프 동작 방식이 있다.
첫 번짼 대부분의 프로그래밍 언어에서 쓰는 렉시컬 스코프
두 번짼 동적 스코프

해당 챕터는 렉스컬 스코프 동작 방식에 대해서 이해하는 파트이다.

## 1. Rex Time
앞 Chapter에서 살펴본 토크나이징(혹은 렉싱)은 소스 코드를 분석하여 상태 유지 파싱의 결과로 생성된 토큰에 의미를 부여하는 과정이다.
렉스 타임이라는 것은 렉시컬 스코프가 정의되는 구간인데 코드 작성자가 변수 혹은 블럭을 어디서 작성하는가에 따라서 렉서가 스코프의 위치를 확정 짓는다.

스코프의 깊이에 대해서 먼저 이해를 하자면 아래의 코드를 보자.
```javascript
function foo(a){
	var b = a * 2;
	function foo2(c){
		console.log(a,b,c);
	}
	foo2(b*3);
}
foo(2); // 2,4,12
```
코드 전체를 감싸는 Scope1
foo()함수 내부 코드를 감싸는 Scope2
foo2()함수 내부 코드를 감싸는 Scope3

그렇다면 Scope3에 있는 변수 또는 함수(console.log(), 변수 c)가 Scope2에도 선언되어 있을까?
그렇지 않다. 한 Scope에 있는 변수 또는 함수가 다른 Scope에 이중으로 존재할 수는 없다.

이해한 바로는.
Scope1에는 foo(), 변수 a
Scope2 에는 foo2(), 변수 b
Sco pe3 에는 console.log(), 변수 c
만 존재할 것이다.

##  2. 검색(Search)
그러면, 어떻게 필요한걸 찾아낼까?
```console.log(a,b,c);```에서  같은 스코프에 있는 것은 ```c```뿐인데.
필요한 것을 찾기 위해 1레벨 위에 있는 스코프를 찾아간다. 못 찾으면 또 위로!
만약 찾는다면 그 즉시 멈춘다.

같은 이름의 변수를 서로 다른 스코프에서 정의할 수 있지만(Shadowing), 렉시컬 스코프에서는 문제되지 않는다.
왜냐하면 해당 스코프, 혹은 상위 스코프에서 해당 이름을 찾으면 바로 멈추기 때문이다.
그리고 프로그래머가 애초에 그럴 의도로 정의하지 않기 때문에..?

>글로벌 변수는 window와 같은 최상위 객체에 속하게 된다. 따라서 해당 렉시컬 이름으로 참조하거나 글로벌 객체의 속성을 참조하여 접근할 수도 있다. 
>``` window.a ```
> 글로벌이 아닌 Shadowing 변수는 위의 방식과 같이 접근이 불가능하다.


## 3. 렉시컬을 속여보자
우리는 스코프를 속일 수 있다!

### eval()
eval()함수는 string문자열을 코드화시키는 능력을 지니고 있다.
이는 ```eval("var a=10;");``` 을 하면 eval()함수가 호출되는 시점에 변수 a가 생성되고 이 변수는 eval()함수가 속한 스코프에 속하게 된다.
```javascript
function foo(str,a){
	eval(str);
	console.log(a,b)
}
var b = 10;
foo("var b=20;",30); // 30,20
```
최상위 스코프의 b는 무시된 것을 확인 할 수 있다.
그 이유는 eval()함수가 호출되면서 해당 스코프에 b=20이 선언되었기 때문이다.

즉, eval()이 호출되면 해당 렉시컬 스코프를 수정한다!

> strict mode 에서는 통하지 않는다.


### with
키워드 with도 렉시컬 스코프를 속일 수 있는 기능이지만, 곧 사라질 예정이다.
with는 객체의 속성에 접근할 때 매번 앞에 객체의 이름을 적는 것이 귀찮아서 생긴 키워드다.

```javascript
var o = {
	a:1
}
function a(obj){
	with(obj){
		b=2;
	}
}
a(o); // undefined
console.log(b) // 2 (?)
```
우리는 분명 b를 선언하지 않았는데.. 값을 가져왔다?
with는 객체를 받으면 독립적인 렉시컬 스코프처럼 행동하기 때문에 가능하다.
무슨 뜻이냐면, 객체 o를 받아서 o라는 렉시컬 스코프를 하나 만든다.

o라는 렉시컬 스코프에는 a밖에 존재하지 않기에 b를 찾기 위해 다른 스코프 영역을 뒤적뒤적한다.
하지만 글로벌 스코프까지 가도 b는 존재하지 않고, 자동으로 ``` b=2;```가 실행되어 
글로벌 스코프에 변수 b가 생성되는 것이다!

정말로 위와 같은 방식을 사용하지 않기를 권한다.
> 해당 로직 역시 strict mode에서는 적용되지 않는다!

## 4. 성능
with나 eval()은 컴파일레이션 단계를 지나 실행이 된다.

여기서 핵심은 **컴파일레이션 단계에서 최적화가 진행된다.** 인데
with나 eval()로 인해서 렉시컬 스코프의 내용이 수정된다면 컴파일레이션 단계에서 최적화된, 즉 변수들의 위치가 바뀔 수도 있는 것이다.
이로 인해 최적화는 무용지물이 될 것이고, 바뀐 위치를 찾기위해서 또한 시간이 걸릴 것이다.

결과가 어떻든, 위의 방법은 느리게 동작시키는 주된 원인이 될 수밖에 없다.


## 5. 결론
렉시컬 스코프가 작동되는 방식을 생각하면서 코드 블럭을 작성하자. 
내가 작성한 코드를 컴파일레이션 단계에서 최적화 시키기 때문이다!

>with나 eval()은 성능을 저하시키는 요인이기에 절대로 사용하지 말자.
